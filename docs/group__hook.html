<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>taiHEN: Hooks Interface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">taiHEN
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">CFW framework for PS Vita</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle">
<div class="title">Hooks Interface<div class="ingroups"><a class="el" href="group__taihen.html">API Interface</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Patches functions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__tai__hook__user.html">_tai_hook_user</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal structure.  <a href="struct__tai__hook__user.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga2b5e8c88ef37e23a0664928410c0b7c8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hook.html#ga2b5e8c88ef37e23a0664928410c0b7c8">TAI_CONTINUE</a>(type,  hook, ...)</td></tr>
<tr class="memdesc:ga2b5e8c88ef37e23a0664928410c0b7c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the next function in the chain.  <a href="#ga2b5e8c88ef37e23a0664928410c0b7c8">More...</a><br /></td></tr>
<tr class="separator:ga2b5e8c88ef37e23a0664928410c0b7c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gac10ef3a300e9826453a63ed3c1f0cc3f"><td class="memItemLeft" align="right" valign="top">typedef uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hook.html#gac10ef3a300e9826453a63ed3c1f0cc3f">tai_hook_ref_t</a></td></tr>
<tr class="memdesc:gac10ef3a300e9826453a63ed3c1f0cc3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hook information.  <a href="#gac10ef3a300e9826453a63ed3c1f0cc3f">More...</a><br /></td></tr>
<tr class="separator:gac10ef3a300e9826453a63ed3c1f0cc3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Kernel Hooks</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp199ca96f8a266aeac7a1e4bb7a46b521"></a>Hooks exports to kernel </p>
</td></tr>
<tr class="memitem:ga0c5ff1adde46b4b23533ab701112874b"><td class="memItemLeft" align="right" valign="top">SceUID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hook.html#ga0c5ff1adde46b4b23533ab701112874b">taiHookFunctionAbs</a> (SceUID pid, <a class="el" href="group__hook.html#gac10ef3a300e9826453a63ed3c1f0cc3f">tai_hook_ref_t</a> *p_hook, void *dest_func, const void *hook_func)</td></tr>
<tr class="memdesc:ga0c5ff1adde46b4b23533ab701112874b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a hook given an absolute address.  <a href="#ga0c5ff1adde46b4b23533ab701112874b">More...</a><br /></td></tr>
<tr class="separator:ga0c5ff1adde46b4b23533ab701112874b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4da6ada9fcf53651839edc0b6e72611"><td class="memItemLeft" align="right" valign="top">SceUID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hook.html#gab4da6ada9fcf53651839edc0b6e72611">taiHookFunctionExportForKernel</a> (SceUID pid, <a class="el" href="group__hook.html#gac10ef3a300e9826453a63ed3c1f0cc3f">tai_hook_ref_t</a> *p_hook, const char *module, uint32_t library_nid, uint32_t func_nid, const void *hook_func)</td></tr>
<tr class="memdesc:gab4da6ada9fcf53651839edc0b6e72611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a hook to a module function export.  <a href="#gab4da6ada9fcf53651839edc0b6e72611">More...</a><br /></td></tr>
<tr class="separator:gab4da6ada9fcf53651839edc0b6e72611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6db61f90fde2aded4b94fbd2bfd808ba"><td class="memItemLeft" align="right" valign="top">SceUID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hook.html#ga6db61f90fde2aded4b94fbd2bfd808ba">taiHookFunctionImportForKernel</a> (SceUID pid, <a class="el" href="group__hook.html#gac10ef3a300e9826453a63ed3c1f0cc3f">tai_hook_ref_t</a> *p_hook, const char *module, uint32_t import_library_nid, uint32_t import_func_nid, const void *hook_func)</td></tr>
<tr class="memdesc:ga6db61f90fde2aded4b94fbd2bfd808ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a hook to a module function import.  <a href="#ga6db61f90fde2aded4b94fbd2bfd808ba">More...</a><br /></td></tr>
<tr class="separator:ga6db61f90fde2aded4b94fbd2bfd808ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabeb678d55d90c14545b9982b45e7c876"><td class="memItemLeft" align="right" valign="top">SceUID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hook.html#gabeb678d55d90c14545b9982b45e7c876">taiHookFunctionOffsetForKernel</a> (SceUID pid, <a class="el" href="group__hook.html#gac10ef3a300e9826453a63ed3c1f0cc3f">tai_hook_ref_t</a> *p_hook, SceUID modid, int segidx, uint32_t offset, int thumb, const void *hook_func)</td></tr>
<tr class="memdesc:gabeb678d55d90c14545b9982b45e7c876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a hook to a module manually with an offset.  <a href="#gabeb678d55d90c14545b9982b45e7c876">More...</a><br /></td></tr>
<tr class="separator:gabeb678d55d90c14545b9982b45e7c876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf58dd77a0a2ebc64a1e76e9df521f230"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hook.html#gaf58dd77a0a2ebc64a1e76e9df521f230">taiGetModuleInfoForKernel</a> (SceUID pid, const char *module, <a class="el" href="group__taihen.html#gaf8ec630dd11d7c647e9ca2cc2f5f08ad">tai_module_info_t</a> *info)</td></tr>
<tr class="memdesc:gaf58dd77a0a2ebc64a1e76e9df521f230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets information on a currently loaded module.  <a href="#gaf58dd77a0a2ebc64a1e76e9df521f230">More...</a><br /></td></tr>
<tr class="separator:gaf58dd77a0a2ebc64a1e76e9df521f230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa71cf17b830797d64f7f21158139e967"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hook.html#gaa71cf17b830797d64f7f21158139e967">taiHookReleaseForKernel</a> (SceUID tai_uid, <a class="el" href="group__hook.html#gac10ef3a300e9826453a63ed3c1f0cc3f">tai_hook_ref_t</a> hook)</td></tr>
<tr class="memdesc:gaa71cf17b830797d64f7f21158139e967"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a hook.  <a href="#gaa71cf17b830797d64f7f21158139e967">More...</a><br /></td></tr>
<tr class="separator:gaa71cf17b830797d64f7f21158139e967"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
User Hooks</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpdcdb34b611fd3b75a8bf26fc0558e1be"></a>Hooks exports to user </p>
</td></tr>
<tr class="memitem:ga098c20b5ba68878729da8dc6ef4238fb"><td class="memItemLeft" align="right" valign="top">SceUID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hook.html#ga098c20b5ba68878729da8dc6ef4238fb">taiHookFunctionExportForUser</a> (<a class="el" href="group__hook.html#gac10ef3a300e9826453a63ed3c1f0cc3f">tai_hook_ref_t</a> *p_hook, <a class="el" href="group__taihen.html#ga80b69aa78bda55d9deaab853234f5b9b">tai_hook_args_t</a> *args)</td></tr>
<tr class="memdesc:ga098c20b5ba68878729da8dc6ef4238fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a hook to a module function export for the calling process.  <a href="#ga098c20b5ba68878729da8dc6ef4238fb">More...</a><br /></td></tr>
<tr class="separator:ga098c20b5ba68878729da8dc6ef4238fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga942b2d3c0bec6e670417949cfaf9b182"><td class="memItemLeft" align="right" valign="top">SceUID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hook.html#ga942b2d3c0bec6e670417949cfaf9b182">taiHookFunctionImportForUser</a> (<a class="el" href="group__hook.html#gac10ef3a300e9826453a63ed3c1f0cc3f">tai_hook_ref_t</a> *p_hook, <a class="el" href="group__taihen.html#ga80b69aa78bda55d9deaab853234f5b9b">tai_hook_args_t</a> *args)</td></tr>
<tr class="memdesc:ga942b2d3c0bec6e670417949cfaf9b182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a hook to a module function import for the calling process.  <a href="#ga942b2d3c0bec6e670417949cfaf9b182">More...</a><br /></td></tr>
<tr class="separator:ga942b2d3c0bec6e670417949cfaf9b182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1b4a779a32fa2a2a49c606c5fc0d6de"><td class="memItemLeft" align="right" valign="top">SceUID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hook.html#gad1b4a779a32fa2a2a49c606c5fc0d6de">taiHookFunctionOffsetForUser</a> (<a class="el" href="group__hook.html#gac10ef3a300e9826453a63ed3c1f0cc3f">tai_hook_ref_t</a> *p_hook, <a class="el" href="group__taihen.html#ga11b170a95065811a28f4c96e3b98a1da">tai_offset_args_t</a> *args)</td></tr>
<tr class="memdesc:gad1b4a779a32fa2a2a49c606c5fc0d6de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a hook to a module manually with an offset for the calling process.  <a href="#gad1b4a779a32fa2a2a49c606c5fc0d6de">More...</a><br /></td></tr>
<tr class="separator:gad1b4a779a32fa2a2a49c606c5fc0d6de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab67b879133ad7f48f8b2d161f5ebba82"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hook.html#gab67b879133ad7f48f8b2d161f5ebba82">taiGetModuleInfo</a> (const char *module, <a class="el" href="group__taihen.html#gaf8ec630dd11d7c647e9ca2cc2f5f08ad">tai_module_info_t</a> *info)</td></tr>
<tr class="memdesc:gab67b879133ad7f48f8b2d161f5ebba82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets information on a currently loaded module.  <a href="#gab67b879133ad7f48f8b2d161f5ebba82">More...</a><br /></td></tr>
<tr class="separator:gab67b879133ad7f48f8b2d161f5ebba82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23d24ea46116a54698618af35b39aea6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hook.html#ga23d24ea46116a54698618af35b39aea6">taiHookRelease</a> (SceUID tai_uid, <a class="el" href="group__hook.html#gac10ef3a300e9826453a63ed3c1f0cc3f">tai_hook_ref_t</a> hook)</td></tr>
<tr class="memdesc:ga23d24ea46116a54698618af35b39aea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a hook for the calling process.  <a href="#ga23d24ea46116a54698618af35b39aea6">More...</a><br /></td></tr>
<tr class="separator:ga23d24ea46116a54698618af35b39aea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae05ef14d7925e68acaea4749ac6b79af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__taihen.html#ga5cde8e1b2cda53e38dbb028451c84074">HELPER</a> SceUID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hook.html#gae05ef14d7925e68acaea4749ac6b79af">taiHookFunctionExport</a> (<a class="el" href="group__hook.html#gac10ef3a300e9826453a63ed3c1f0cc3f">tai_hook_ref_t</a> *p_hook, const char *module, uint32_t library_nid, uint32_t func_nid, const void *hook_func)</td></tr>
<tr class="memdesc:gae05ef14d7925e68acaea4749ac6b79af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for <a class="el" href="group__hook.html#ga098c20b5ba68878729da8dc6ef4238fb" title="Add a hook to a module function export for the calling process. ">taiHookFunctionExportForUser</a>.  <a href="#gae05ef14d7925e68acaea4749ac6b79af">More...</a><br /></td></tr>
<tr class="separator:gae05ef14d7925e68acaea4749ac6b79af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga795597abd9e27d4e9e3f556b12d8a402"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__taihen.html#ga5cde8e1b2cda53e38dbb028451c84074">HELPER</a> SceUID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hook.html#ga795597abd9e27d4e9e3f556b12d8a402">taiHookFunctionImport</a> (<a class="el" href="group__hook.html#gac10ef3a300e9826453a63ed3c1f0cc3f">tai_hook_ref_t</a> *p_hook, const char *module, uint32_t import_library_nid, uint32_t import_func_nid, const void *hook_func)</td></tr>
<tr class="memdesc:ga795597abd9e27d4e9e3f556b12d8a402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for <a class="el" href="group__hook.html#ga942b2d3c0bec6e670417949cfaf9b182" title="Add a hook to a module function import for the calling process. ">taiHookFunctionImportForUser</a>.  <a href="#ga795597abd9e27d4e9e3f556b12d8a402">More...</a><br /></td></tr>
<tr class="separator:ga795597abd9e27d4e9e3f556b12d8a402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80b3ff70e0aeb17d99ee3c37b51d77bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__taihen.html#ga5cde8e1b2cda53e38dbb028451c84074">HELPER</a> SceUID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hook.html#ga80b3ff70e0aeb17d99ee3c37b51d77bb">taiHookFunctionOffset</a> (<a class="el" href="group__hook.html#gac10ef3a300e9826453a63ed3c1f0cc3f">tai_hook_ref_t</a> *p_hook, SceUID modid, int segidx, uint32_t offset, int thumb, const void *hook_func)</td></tr>
<tr class="memdesc:ga80b3ff70e0aeb17d99ee3c37b51d77bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for <a class="el" href="group__hook.html#gad1b4a779a32fa2a2a49c606c5fc0d6de" title="Add a hook to a module manually with an offset for the calling process. ">taiHookFunctionOffsetForUser</a>.  <a href="#ga80b3ff70e0aeb17d99ee3c37b51d77bb">More...</a><br /></td></tr>
<tr class="separator:ga80b3ff70e0aeb17d99ee3c37b51d77bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Patches functions. </p>
<p>A function hook allows a plugin to run code before and after a any function call. As an example, say we wish to hook <code>sceIoOpenForDriver</code></p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <a class="code" href="group__hook.html#gac10ef3a300e9826453a63ed3c1f0cc3f">tai_hook_ref_t</a> open_ref;</div><div class="line"><a class="code" href="group__hook.html#gab4da6ada9fcf53651839edc0b6e72611">taiHookFunctionExportForKernel</a>(<a class="code" href="group__taihen.html#ga504edcb943700beca9c23eba3fca56cd">KERNEL_PID</a>, &amp;open_ref, <span class="stringliteral">&quot;SceIofilemgr&quot;</span>, <a class="code" href="group__taihen.html#gacd164ffaddd77a07b09309a1a7bc84ec">TAI_ANY_LIBRARY</a>, 0x75192972, open_hook);</div></div><!-- fragment --><p>If we wish to log the path of any kernel file opens, we can write this</p>
<div class="fragment"><div class="line">SceUID open_hook(<span class="keyword">const</span> <span class="keywordtype">char</span> *path, <span class="keywordtype">int</span> flags, SceMode mode) {</div><div class="line">  printf(<span class="stringliteral">&quot;opened: %s\n&quot;</span>, path);</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="group__hook.html#ga2b5e8c88ef37e23a0664928410c0b7c8">TAI_CONTINUE</a>(SceUID, open_ref, path, flags, mode);</div><div class="line">}</div></div><!-- fragment --><p>Note that it is the user's responsibility to ensure that the function prototype matches. What if we want to log the return values too?</p>
<div class="fragment"><div class="line">SceUID open_hook(<span class="keyword">const</span> <span class="keywordtype">char</span> *path, <span class="keywordtype">int</span> flags, SceMode mode) {</div><div class="line">  SceUID ret = <a class="code" href="group__hook.html#ga2b5e8c88ef37e23a0664928410c0b7c8">TAI_CONTINUE</a>(SceUID, open_ref, path, flags, mode);</div><div class="line">  printf(<span class="stringliteral">&quot;opened: %s, return: %x\n&quot;</span>, path, ret);</div><div class="line">  <span class="keywordflow">return</span> ret;</div><div class="line">}</div></div><!-- fragment --><p>For a more complicated example, we can redirect a file open as follows</p>
<div class="fragment"><div class="line">SceUID open_hook(<span class="keyword">const</span> <span class="keywordtype">char</span> *path, <span class="keywordtype">int</span> flags, SceMode mode) {</div><div class="line">  SceUID ret;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (strcmp(path, <span class="stringliteral">&quot;ux0:id.dat&quot;</span>) == 0) {</div><div class="line">    path = <span class="stringliteral">&quot;ux0:id-redirect.dat&quot;</span>;</div><div class="line">    printf(<span class="stringliteral">&quot;redirecting path\n&quot;</span>);</div><div class="line">  }</div><div class="line"></div><div class="line">  ret = <a class="code" href="group__hook.html#ga2b5e8c88ef37e23a0664928410c0b7c8">TAI_CONTINUE</a>(SceUID, open_ref, path, flags, mode);</div><div class="line">  printf(<span class="stringliteral">&quot;opened: %s, return: %x\n&quot;</span>, path, ret);</div><div class="line">  <span class="keywordflow">return</span> ret;</div><div class="line">}</div></div><!-- fragment --><p>Note that we use the <code>TAI_CONTINUE</code> macro in order to continue the chain. You should <em>always do this</em> because it ensures all hooks get their share of the pie. Consider this bad example</p>
<div class="fragment"><div class="line">SceUID bad_open_hook(<span class="keyword">const</span> <span class="keywordtype">char</span> *path, <span class="keywordtype">int</span> flags, SceMode mode) {</div><div class="line">  <span class="keywordflow">if</span> (strcmp(path, <span class="stringliteral">&quot;ux0:dontwant.bin&quot;</span>) == 0) {</div><div class="line">    <span class="keywordflow">return</span> SCE_KERNEL_ERROR_NOENT;</div><div class="line">  } <span class="keywordflow">else</span> {</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="group__hook.html#ga2b5e8c88ef37e23a0664928410c0b7c8">TAI_CONTINUE</a>(SceUID, open_ref, path, flags, mode);</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>This prevents any other hooks from running. This would break, for example, our logging hook above. Instead you should do</p>
<div class="fragment"><div class="line">SceUID good_open_hook(<span class="keyword">const</span> <span class="keywordtype">char</span> *path, <span class="keywordtype">int</span> flags, SceMode mode) {</div><div class="line">  SceUID ret;</div><div class="line">  ret = <a class="code" href="group__hook.html#ga2b5e8c88ef37e23a0664928410c0b7c8">TAI_CONTINUE</a>(SceUID, open_ref, path, flags, mode);</div><div class="line">  <span class="keywordflow">if</span> (strcmp(path, <span class="stringliteral">&quot;ux0:dontwant.bin&quot;</span>) == 0) {</div><div class="line">    <span class="keywordflow">return</span> SCE_KERNEL_ERROR_NOENT;</div><div class="line">  } <span class="keywordflow">else</span> {</div><div class="line">    <span class="keywordflow">return</span> ret;</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>Another common use case is the ability to call the original function. The recommended way of doing this is to make the original function call</p>
<div class="fragment"><div class="line">SceUID recurse_open_hook(<span class="keyword">const</span> <span class="keywordtype">char</span> *path, <span class="keywordtype">int</span> flags, SceMode mode) {</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span> *log = <span class="stringliteral">&quot;ux0:lastopen.txt&quot;</span>;</div><div class="line">  SceUID ret;</div><div class="line">  SceUID fd;</div><div class="line">  ret = <a class="code" href="group__hook.html#ga2b5e8c88ef37e23a0664928410c0b7c8">TAI_CONTINUE</a>(SceUID, open_ref, path, flags, mode);</div><div class="line">  <span class="keywordflow">if</span> (path != log &amp;&amp; strncmp(path, <span class="stringliteral">&quot;ux0:&quot;</span>, 4) == 0) {</div><div class="line">    fd = sceIoOpenForDriver(log, SCE_O_WRONLY, 0);</div><div class="line">    sceIoWrite(fd, path, 256);</div><div class="line">    sceIoClose(fd);</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> ret;</div><div class="line">}</div></div><!-- fragment --><p>Note that calling the original <code>sceIoOpenForDriver</code> will recurse back to <code>recurse_open_hook</code> so it is <em>very important</em> to avoid an infinite recursion. In this case, we check that the parameter is not the same, but more complex checks may be needed for other function. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga2b5e8c88ef37e23a0664928410c0b7c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b5e8c88ef37e23a0664928410c0b7c8">&sect;&nbsp;</a></span>TAI_CONTINUE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TAI_CONTINUE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">hook, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">({ \</div><div class="line">  struct <a class="code" href="struct__tai__hook__user.html">_tai_hook_user</a> *cur, *<a class="code" href="struct__tai__proc.html#a230a61dbce373574d8414910ca2a837e">next</a>; \</div><div class="line">  cur = (<span class="keyword">struct </span><a class="code" href="struct__tai__hook__user.html">_tai_hook_user</a> *)(hook); \</div><div class="line">  next = (<span class="keyword">struct </span><a class="code" href="struct__tai__hook__user.html">_tai_hook_user</a> *)cur-&gt;<a class="code" href="struct__tai__proc.html#a230a61dbce373574d8414910ca2a837e">next</a>; \</div><div class="line">  (next == NULL) ? \</div><div class="line">    ((type(*)())cur-&gt;old)(__VA_ARGS__) \</div><div class="line">  : \</div><div class="line">    ((type(*)())next-&gt;func)(__VA_ARGS__) \</div><div class="line">  ; \</div><div class="line">})</div><div class="ttc" id="struct__tai__proc_html_a230a61dbce373574d8414910ca2a837e"><div class="ttname"><a href="struct__tai__proc.html#a230a61dbce373574d8414910ca2a837e">_tai_proc::next</a></div><div class="ttdeci">struct _tai_proc * next</div><div class="ttdoc">Next process in this map bucket. </div><div class="ttdef"><b>Definition:</b> <a href="taihen__internal_8h_source.html#l00107">taihen_internal.h:107</a></div></div>
<div class="ttc" id="struct__tai__hook__user_html"><div class="ttname"><a href="struct__tai__hook__user.html">_tai_hook_user</a></div><div class="ttdoc">Internal structure. </div><div class="ttdef"><b>Definition:</b> <a href="taihen_8h_source.html#l00220">taihen.h:220</a></div></div>
</div><!-- fragment -->
<p>Calls the next function in the chain. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Return type </td></tr>
    <tr><td class="paramname">hook</td><td>The hook continuing the call</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return value from the hook chain </dd></dl>

<p>Definition at line <a class="el" href="taihen_8h_source.html#l00345">345</a> of file <a class="el" href="taihen_8h_source.html">taihen.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gac10ef3a300e9826453a63ed3c1f0cc3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac10ef3a300e9826453a63ed3c1f0cc3f">&sect;&nbsp;</a></span>tai_hook_ref_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uintptr_t <a class="el" href="group__hook.html#gac10ef3a300e9826453a63ed3c1f0cc3f">tai_hook_ref_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hook information. </p>
<p>This reference is created on new hooks and is up to the caller to keep track of. The client is responsible for cleanup by passing the reference back to taiHEN when needed. </p>

<p>Definition at line <a class="el" href="taihen_8h_source.html#l00215">215</a> of file <a class="el" href="taihen_8h_source.html">taihen.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab67b879133ad7f48f8b2d161f5ebba82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab67b879133ad7f48f8b2d161f5ebba82">&sect;&nbsp;</a></span>taiGetModuleInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int taiGetModuleInfo </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__taihen.html#gaf8ec630dd11d7c647e9ca2cc2f5f08ad">tai_module_info_t</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets information on a currently loaded module. </p>
<p>You can use the macro <code>TAI_MAIN_MODULE</code> for <code>module</code> to specify the main module. This is usually the module that is loaded first and is usually the eboot.bin. This will only work if there is only one module loaded in the main memory space. Not all processes have this property! Make sure you check the return value.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__hook.html#gaf58dd77a0a2ebc64a1e76e9df521f230" title="Gets information on a currently loaded module. ">taiGetModuleInfoForKernel</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">module</td><td>The name of the module or <code>TAI_MAIN_MODULE</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>The information to fill</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on success, &lt; 0 on error<ul>
<li>TAI_ERROR_USER_MEMORY if <code>info-&gt;size</code> is too small or large or <code>module</code> is invalid</li>
<li>TAI_ERROR_INVALID_MODULE if <code>TAI_MAIN_MODULE</code> is specified and there are multiple main modules </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="taihen-user_8c_source.html#l00209">209</a> of file <a class="el" href="taihen-user_8c_source.html">taihen-user.c</a>.</p>

</div>
</div>
<a id="gaf58dd77a0a2ebc64a1e76e9df521f230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf58dd77a0a2ebc64a1e76e9df521f230">&sect;&nbsp;</a></span>taiGetModuleInfoForKernel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int taiGetModuleInfoForKernel </td>
          <td>(</td>
          <td class="paramtype">SceUID&#160;</td>
          <td class="paramname"><em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__taihen.html#gaf8ec630dd11d7c647e9ca2cc2f5f08ad">tai_module_info_t</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets information on a currently loaded module. </p>
<p>You should use this before calling <code>taiHookFunctionOffsetForKernel</code> in order to check that the module you wish to hook is currently loaded and that the module NID matches. The module NID changes in each version of the module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pid</td><td>The pid of the <em>caller</em> (kernel should set to KERNEL_PID) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">module</td><td>The name of the module </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>The information to fill</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on success, &lt; 0 on error<ul>
<li>TAI_ERROR_INVALID_MODULE if <code>module</code> is <code>TAI_MAIN_MODULE</code> and <code>pid</code> is kernel </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="taihen_8c_source.html#l00191">191</a> of file <a class="el" href="taihen_8c_source.html">taihen.c</a>.</p>

</div>
</div>
<a id="ga0c5ff1adde46b4b23533ab701112874b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c5ff1adde46b4b23533ab701112874b">&sect;&nbsp;</a></span>taiHookFunctionAbs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SceUID taiHookFunctionAbs </td>
          <td>(</td>
          <td class="paramtype">SceUID&#160;</td>
          <td class="paramname"><em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hook.html#gac10ef3a300e9826453a63ed3c1f0cc3f">tai_hook_ref_t</a> *&#160;</td>
          <td class="paramname"><em>p_hook</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>hook_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a hook given an absolute address. </p>
<p>If target is the kernel, use KERNEL_PID as <code>pid</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pid</td><td>The pid of the target </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_hook</td><td>A reference that can be used by the hook function </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">dest_func</td><td>The function to patch (must be in the target address space) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hook_func</td><td>The hook function (must be in the target address space)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tai patch reference on success, &lt; 0 on error<ul>
<li>TAI_ERROR_PATCH_EXISTS if the address is already patched</li>
<li>TAI_ERROR_HOOK_ERROR if an internal error occurred trying to hook</li>
<li>TAI_ERROR_INVALID_KERNEL_ADDR if <code>pid</code> is kernel and address is in shared memory region </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="taihen_8c_source.html#l00041">41</a> of file <a class="el" href="taihen_8c_source.html">taihen.c</a>.</p>

</div>
</div>
<a id="gae05ef14d7925e68acaea4749ac6b79af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae05ef14d7925e68acaea4749ac6b79af">&sect;&nbsp;</a></span>taiHookFunctionExport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__taihen.html#ga5cde8e1b2cda53e38dbb028451c84074">HELPER</a> SceUID taiHookFunctionExport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__hook.html#gac10ef3a300e9826453a63ed3c1f0cc3f">tai_hook_ref_t</a> *&#160;</td>
          <td class="paramname"><em>p_hook</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>library_nid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>func_nid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>hook_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function for <a class="el" href="group__hook.html#ga098c20b5ba68878729da8dc6ef4238fb" title="Add a hook to a module function export for the calling process. ">taiHookFunctionExportForUser</a>. </p>
<p>You can use the macro <code>TAI_MAIN_MODULE</code> for <code>module</code> to specify the main module. This is usually the module that is loaded first and is usually the eboot.bin. This will only work if there is only one module loaded in the main memory space. Not all processes have this property! Make sure you check the return value.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__hook.html#ga098c20b5ba68878729da8dc6ef4238fb" title="Add a hook to a module function export for the calling process. ">taiHookFunctionExportForUser</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p_hook</td><td>A reference that can be used by the hook function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">module</td><td>Name of the target module or <code>TAI_MAIN_MODULE</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">library_nid</td><td>Optional. NID of the target library. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func_nid</td><td>The function NID. If <code>library_nid</code> is <code>TAI_ANY_LIBRARY</code>, then the first export with the NID will be hooked. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hook_func</td><td>The hook function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>{ description_of_the_return_value } </dd></dl>

<p>Definition at line <a class="el" href="taihen_8h_source.html#l00271">271</a> of file <a class="el" href="taihen_8h_source.html">taihen.h</a>.</p>

</div>
</div>
<a id="gab4da6ada9fcf53651839edc0b6e72611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4da6ada9fcf53651839edc0b6e72611">&sect;&nbsp;</a></span>taiHookFunctionExportForKernel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SceUID taiHookFunctionExportForKernel </td>
          <td>(</td>
          <td class="paramtype">SceUID&#160;</td>
          <td class="paramname"><em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hook.html#gac10ef3a300e9826453a63ed3c1f0cc3f">tai_hook_ref_t</a> *&#160;</td>
          <td class="paramname"><em>p_hook</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>library_nid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>func_nid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>hook_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a hook to a module function export. </p>
<p>If target is the kernel, use KERNEL_PID as <code>pid</code>. Since a module can have two libraries that export the same NID, you can optionally pass in the library NID of the one to hook. Otherwise, use <code>TAI_ANY_LIBRARY</code> and the first one found will be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pid</td><td>The pid of the target </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_hook</td><td>A reference that can be used by the hook function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">module</td><td>Name of the target module. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">library_nid</td><td>Optional. NID of the target library. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func_nid</td><td>The function NID. If <code>library_nid</code> is <code>TAI_ANY_LIBRARY</code>, then the first export with the NID will be hooked. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hook_func</td><td>The hook function (must be in the target address space)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tai patch reference on success, &lt; 0 on error<ul>
<li>TAI_ERROR_PATCH_EXISTS if the address is already patched</li>
<li>TAI_ERROR_HOOK_ERROR if an internal error occurred trying to hook</li>
<li>TAI_ERROR_INVALID_KERNEL_ADDR if <code>pid</code> is kernel and address is in shared memory region</li>
<li>TAI_ERROR_INVALID_MODULE if <code>module</code> is <code>TAI_MAIN_MODULE</code> and <code>pid</code> is kernel </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="taihen_8c_source.html#l00072">72</a> of file <a class="el" href="taihen_8c_source.html">taihen.c</a>.</p>

</div>
</div>
<a id="ga098c20b5ba68878729da8dc6ef4238fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga098c20b5ba68878729da8dc6ef4238fb">&sect;&nbsp;</a></span>taiHookFunctionExportForUser()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SceUID taiHookFunctionExportForUser </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__hook.html#gac10ef3a300e9826453a63ed3c1f0cc3f">tai_hook_ref_t</a> *&#160;</td>
          <td class="paramname"><em>p_hook</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__taihen.html#ga80b69aa78bda55d9deaab853234f5b9b">tai_hook_args_t</a> *&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a hook to a module function export for the calling process. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__hook.html#gab4da6ada9fcf53651839edc0b6e72611" title="Add a hook to a module function export. ">taiHookFunctionExportForKernel</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p_hook</td><td>A reference that can be used by the hook function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Call arguments</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tai patch reference on success, &lt; 0 on error<ul>
<li>TAI_ERROR_PATCH_EXISTS if the address is already patched</li>
<li>TAI_ERROR_HOOK_ERROR if an internal error occurred trying to hook</li>
<li>TAI_ERROR_NOT_IMPLEMENTED if address is in shared memory region</li>
<li>TAI_ERROR_USER_MEMORY if pointers are incorrect</li>
<li>TAI_ERROR_INVALID_MODULE if <code>TAI_MAIN_MODULE</code> is specified and there are multiple main modules </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="taihen-user_8c_source.html#l00044">44</a> of file <a class="el" href="taihen-user_8c_source.html">taihen-user.c</a>.</p>

</div>
</div>
<a id="ga795597abd9e27d4e9e3f556b12d8a402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga795597abd9e27d4e9e3f556b12d8a402">&sect;&nbsp;</a></span>taiHookFunctionImport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__taihen.html#ga5cde8e1b2cda53e38dbb028451c84074">HELPER</a> SceUID taiHookFunctionImport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__hook.html#gac10ef3a300e9826453a63ed3c1f0cc3f">tai_hook_ref_t</a> *&#160;</td>
          <td class="paramname"><em>p_hook</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>import_library_nid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>import_func_nid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>hook_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function for <a class="el" href="group__hook.html#ga942b2d3c0bec6e670417949cfaf9b182" title="Add a hook to a module function import for the calling process. ">taiHookFunctionImportForUser</a>. </p>
<p>You can use the macro <code>TAI_MAIN_MODULE</code> for <code>module</code> to specify the main module. This is usually the module that is loaded first and is usually the eboot.bin. This will only work if there is only one module loaded in the main memory space. Not all processes have this property! Make sure you check the return value.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__hook.html#ga942b2d3c0bec6e670417949cfaf9b182" title="Add a hook to a module function import for the calling process. ">taiHookFunctionImportForUser</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p_hook</td><td>A reference that can be used by the hook function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">module</td><td>Name of the target module or <code>TAI_MAIN_MODULE</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">import_library_nid</td><td>The imported library from the target module </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">import_func_nid</td><td>The function NID of the import </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hook_func</td><td>The hook function </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="taihen_8h_source.html#l00301">301</a> of file <a class="el" href="taihen_8h_source.html">taihen.h</a>.</p>

</div>
</div>
<a id="ga6db61f90fde2aded4b94fbd2bfd808ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6db61f90fde2aded4b94fbd2bfd808ba">&sect;&nbsp;</a></span>taiHookFunctionImportForKernel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SceUID taiHookFunctionImportForKernel </td>
          <td>(</td>
          <td class="paramtype">SceUID&#160;</td>
          <td class="paramname"><em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hook.html#gac10ef3a300e9826453a63ed3c1f0cc3f">tai_hook_ref_t</a> *&#160;</td>
          <td class="paramname"><em>p_hook</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>import_library_nid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>import_func_nid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>hook_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a hook to a module function import. </p>
<p>If target is the kernel, use KERNEL_PID as <code>pid</code>. This will let you hook calls from one module to another without having to hook all calls to that module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pid</td><td>The pid of the target </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_hook</td><td>A reference that can be used by the hook function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">module</td><td>Name of the target module. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">import_library_nid</td><td>The imported library from the target module </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">import_func_nid</td><td>The function NID of the import </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hook_func</td><td>The hook function (must be in the target address space)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tai patch reference on success, &lt; 0 on error<ul>
<li>TAI_ERROR_PATCH_EXISTS if the address is already patched</li>
<li>TAI_ERROR_HOOK_ERROR if an internal error occurred trying to hook</li>
<li>TAI_ERROR_INVALID_KERNEL_ADDR if <code>pid</code> is kernel and address is in shared memory region</li>
<li>TAI_ERROR_STUB_NOT_RESOLVED if the import has not been resolved yet. You should hook <code>sceKernelLoadStartModule</code>, <code>sceSysmoduleLoadModule</code> or whatever the application uses to start the imported module and add this hook after the module is loaded. Be sure to also hook module unloading to remove the hook BEFORE the imported module is unloaded!</li>
<li>TAI_ERROR_INVALID_MODULE if <code>module</code> is <code>TAI_MAIN_MODULE</code> and <code>pid</code> is kernel </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="taihen_8c_source.html#l00115">115</a> of file <a class="el" href="taihen_8c_source.html">taihen.c</a>.</p>

</div>
</div>
<a id="ga942b2d3c0bec6e670417949cfaf9b182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga942b2d3c0bec6e670417949cfaf9b182">&sect;&nbsp;</a></span>taiHookFunctionImportForUser()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SceUID taiHookFunctionImportForUser </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__hook.html#gac10ef3a300e9826453a63ed3c1f0cc3f">tai_hook_ref_t</a> *&#160;</td>
          <td class="paramname"><em>p_hook</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__taihen.html#ga80b69aa78bda55d9deaab853234f5b9b">tai_hook_args_t</a> *&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a hook to a module function import for the calling process. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__hook.html#ga6db61f90fde2aded4b94fbd2bfd808ba" title="Add a hook to a module function import. ">taiHookFunctionImportForKernel</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p_hook</td><td>A reference that can be used by the hook function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Call arguments</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tai patch reference on success, &lt; 0 on error<ul>
<li>TAI_ERROR_PATCH_EXISTS if the address is already patched</li>
<li>TAI_ERROR_HOOK_ERROR if an internal error occurred trying to hook</li>
<li>TAI_ERROR_NOT_IMPLEMENTED if address is in shared memory region. You should hook an import from another module instead.</li>
<li>TAI_ERROR_USER_MEMORY if pointers are incorrect</li>
<li>TAI_ERROR_STUB_NOT_RESOLVED if the import has not been resolved yet. You should hook <code>sceKernelLoadStartModule</code>, <code>sceSysmoduleLoadModule</code> or whatever the application uses to start the imported module and add this hook after the module is loaded. Be sure to also hook module unloading to remove the hook BEFORE the imported module is unloaded!</li>
<li>TAI_ERROR_INVALID_MODULE if <code>TAI_MAIN_MODULE</code> is specified and there are multiple main modules </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="taihen-user_8c_source.html#l00105">105</a> of file <a class="el" href="taihen-user_8c_source.html">taihen-user.c</a>.</p>

</div>
</div>
<a id="ga80b3ff70e0aeb17d99ee3c37b51d77bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80b3ff70e0aeb17d99ee3c37b51d77bb">&sect;&nbsp;</a></span>taiHookFunctionOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__taihen.html#ga5cde8e1b2cda53e38dbb028451c84074">HELPER</a> SceUID taiHookFunctionOffset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__hook.html#gac10ef3a300e9826453a63ed3c1f0cc3f">tai_hook_ref_t</a> *&#160;</td>
          <td class="paramname"><em>p_hook</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SceUID&#160;</td>
          <td class="paramname"><em>modid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>segidx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thumb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>hook_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function for <a class="el" href="group__hook.html#gad1b4a779a32fa2a2a49c606c5fc0d6de" title="Add a hook to a module manually with an offset for the calling process. ">taiHookFunctionOffsetForUser</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__hook.html#gad1b4a779a32fa2a2a49c606c5fc0d6de" title="Add a hook to a module manually with an offset for the calling process. ">taiHookFunctionOffsetForUser</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p_hook</td><td>A reference that can be used by the hook function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">modid</td><td>The module UID from <code>taiGetModuleInfo</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">segidx</td><td>The ELF segment index containing the function to patch </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The offset from the start of the segment </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thumb</td><td>Set to 1 if this is a Thumb function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hook_func</td><td>The hook function (must be in the target address space) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="taihen_8h_source.html#l00324">324</a> of file <a class="el" href="taihen_8h_source.html">taihen.h</a>.</p>

</div>
</div>
<a id="gabeb678d55d90c14545b9982b45e7c876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabeb678d55d90c14545b9982b45e7c876">&sect;&nbsp;</a></span>taiHookFunctionOffsetForKernel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SceUID taiHookFunctionOffsetForKernel </td>
          <td>(</td>
          <td class="paramtype">SceUID&#160;</td>
          <td class="paramname"><em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hook.html#gac10ef3a300e9826453a63ed3c1f0cc3f">tai_hook_ref_t</a> *&#160;</td>
          <td class="paramname"><em>p_hook</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SceUID&#160;</td>
          <td class="paramname"><em>modid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>segidx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thumb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>hook_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a hook to a module manually with an offset. </p>
<p>If target is the kernel, use KERNEL_PID as <code>pid</code>. The caller is responsible for checking that the module is of the correct version!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pid</td><td>The pid of the target </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_hook</td><td>A reference that can be used by the hook function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">modid</td><td>The module UID from <code>taiGetModuleInfoForKernel</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">segidx</td><td>The ELF segment index containing the function to patch </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The offset from the start of the segment </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thumb</td><td>Set to 1 if this is a Thumb function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hook_func</td><td>The hook function (must be in the target address space)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tai patch reference on success, &lt; 0 on error<ul>
<li>TAI_ERROR_PATCH_EXISTS if the address is already patched</li>
<li>TAI_ERROR_HOOK_ERROR if an internal error occurred trying to hook</li>
<li>TAI_ERROR_INVALID_KERNEL_ADDR if <code>pid</code> is kernel and address is in shared memory region </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="taihen_8c_source.html#l00159">159</a> of file <a class="el" href="taihen_8c_source.html">taihen.c</a>.</p>

</div>
</div>
<a id="gad1b4a779a32fa2a2a49c606c5fc0d6de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1b4a779a32fa2a2a49c606c5fc0d6de">&sect;&nbsp;</a></span>taiHookFunctionOffsetForUser()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SceUID taiHookFunctionOffsetForUser </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__hook.html#gac10ef3a300e9826453a63ed3c1f0cc3f">tai_hook_ref_t</a> *&#160;</td>
          <td class="paramname"><em>p_hook</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__taihen.html#ga11b170a95065811a28f4c96e3b98a1da">tai_offset_args_t</a> *&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a hook to a module manually with an offset for the calling process. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__hook.html#gabeb678d55d90c14545b9982b45e7c876" title="Add a hook to a module manually with an offset. ">taiHookFunctionOffsetForKernel</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p_hook</td><td>A reference that can be used by the hook function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Call arguments</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tai patch reference on success, &lt; 0 on error<ul>
<li>TAI_ERROR_PATCH_EXISTS if the address is already patched</li>
<li>TAI_ERROR_HOOK_ERROR if an internal error occurred trying to hook</li>
<li>TAI_ERROR_NOT_IMPLEMENTED if address is in shared memory region</li>
<li>TAI_ERROR_USER_MEMORY if pointers are incorrect </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="taihen-user_8c_source.html#l00155">155</a> of file <a class="el" href="taihen-user_8c_source.html">taihen-user.c</a>.</p>

</div>
</div>
<a id="ga23d24ea46116a54698618af35b39aea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23d24ea46116a54698618af35b39aea6">&sect;&nbsp;</a></span>taiHookRelease()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int taiHookRelease </td>
          <td>(</td>
          <td class="paramtype">SceUID&#160;</td>
          <td class="paramname"><em>tai_uid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hook.html#gac10ef3a300e9826453a63ed3c1f0cc3f">tai_hook_ref_t</a>&#160;</td>
          <td class="paramname"><em>hook</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release a hook for the calling process. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__hook.html#gaa71cf17b830797d64f7f21158139e967" title="Release a hook. ">taiHookReleaseForKernel</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tai_uid</td><td>The tai patch reference to free </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hook</td><td>The hook to free</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on success, &lt; 0 on error<ul>
<li>TAI_ERROR_HOOK_ERROR if an internal error occurred trying to restore the function </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="taihen-user_8c_source.html#l00246">246</a> of file <a class="el" href="taihen-user_8c_source.html">taihen-user.c</a>.</p>

</div>
</div>
<a id="gaa71cf17b830797d64f7f21158139e967"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa71cf17b830797d64f7f21158139e967">&sect;&nbsp;</a></span>taiHookReleaseForKernel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int taiHookReleaseForKernel </td>
          <td>(</td>
          <td class="paramtype">SceUID&#160;</td>
          <td class="paramname"><em>tai_uid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hook.html#gac10ef3a300e9826453a63ed3c1f0cc3f">tai_hook_ref_t</a>&#160;</td>
          <td class="paramname"><em>hook</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release a hook. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tai_uid</td><td>The tai patch reference to free </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hook</td><td>The hook to free</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on success, &lt; 0 on error<ul>
<li>TAI_ERROR_HOOK_ERROR if an internal error occurred trying to restore the function </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="taihen_8c_source.html#l00204">204</a> of file <a class="el" href="taihen_8c_source.html">taihen.c</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.12
</small></address>
</body>
</html>
